# Cirrus CI - Showcase: Build stremio-server on ARM64
#
# This is a simplified example showing Cirrus CI ARM64 native builds.
# stremio-server is a pure Node.js application (no compilation needed)
# so it builds quickly without QEMU complexity.
#
# For production builds of all packages, see GitHub Actions which uses
# native ARM64 runners (ubuntu-24.04-arm) with bubblewrap for fast builds.

task:
  name: Build stremio-server (ARM64 showcase)
  only_if: $CIRRUS_BRANCH == 'master' || $CIRRUS_BRANCH == 'main'

  # ARM64 native on AWS Graviton2 - lightweight resources for simple builds
  arm_container:
    image: alpine:latest
    cpu: 2
    memory: 4G

  env:
    ARCH: aarch64
    MELANGE_VERSION: latest
    APK_SIGNING_KEY: ENCRYPTED[!1ef534804032cc4990b3feb5c4dbe292a23b5003dbfacd059aa9ca3ea63a950eb975838ae6e1305303df4217c8caf97c!]

  # Install dependencies (including QEMU for emulation)
  install_deps_script:
    - apk add --no-cache curl git bash qemu-system-aarch64 linux-virt wget tar gzip jq openssl cpio file
    - |
      # Check if virtio modules are available in the installed system
      echo "Checking for virtio modules in installed system..."
      if [ -d "/lib/modules" ]; then
        echo "  System modules directory exists:"
        ls -la /lib/modules/ 2>/dev/null | head -5
        KERNEL_VER=$(ls /lib/modules/ 2>/dev/null | head -1)
        if [ -n "$KERNEL_VER" ]; then
          echo "  Found kernel version: $KERNEL_VER"
          echo "  Searching for virtio modules:"
          find /lib/modules/$KERNEL_VER -name "*virtio*" -type f 2>/dev/null | head -10 || echo "    No virtio modules found in system"
        fi
      fi

  # Install Melange
  install_melange_script:
    - |
      ACTUAL_VERSION=$(curl -s https://api.github.com/repos/chainguard-dev/melange/releases/latest | jq -r '.tag_name')
      echo "Installing Melange $ACTUAL_VERSION for ARM64"
      wget -q https://github.com/chainguard-dev/melange/releases/download/${ACTUAL_VERSION}/melange_${ACTUAL_VERSION#v}_linux_arm64.tar.gz
      tar -xzf melange_${ACTUAL_VERSION#v}_linux_arm64.tar.gz
      find . -name "melange" -type f -exec mv {} /usr/local/bin/ \;
      chmod +x /usr/local/bin/melange
      melange version
      rm -f melange_${ACTUAL_VERSION#v}_linux_arm64.tar.gz

  # Create QEMU wrapper to force TCG instead of KVM (KVM not available in container)
  setup_qemu_wrapper_script:
    - |
      # Move real QEMU binary
      mv /usr/bin/qemu-system-aarch64 /usr/bin/qemu-system-aarch64.real

      # Create wrapper script that replaces -accel kvm with -accel tcg,thread=multi
      # Also fixes memory and CPU settings for TCG
      cat > /usr/bin/qemu-system-aarch64 << 'EOF'
      #!/bin/sh
      # QEMU wrapper to force TCG acceleration instead of KVM
      # KVM is not available in Cirrus CI ARM containers

      # Debug logging
      echo "=== QEMU wrapper invoked at $(date) ===" >> /tmp/qemu-debug.log
      echo "Original arguments:" >> /tmp/qemu-debug.log
      for arg in "$@"; do
        echo "  '$arg'" >> /tmp/qemu-debug.log
      done

      # Process arguments to replace problematic values
      # - Replace -accel kvm with -accel tcg,thread=multi (KVM not available)
      # - Replace -m <value> with -m 16G (cap memory, Melange calculates wrong value)
      # - Replace -machine <value> with -machine virt (ensure 64-bit addressing)
      # - Replace -cpu host with -cpu max (TCG needs explicit CPU, not host)
      new_args=""
      prev_arg=""
      skip_next=false
      skip_reason=""

      for arg in "$@"; do
        # Skip this iteration if previous arg was -m, -machine, or -cpu (we already added our replacement)
        if [ "$skip_next" = true ]; then
          skip_next=false
          echo "Replaced $skip_reason value '$arg' with replacement" >> /tmp/qemu-debug.log
          prev_arg=""
          skip_reason=""
          continue
        fi

        # Replace -accel kvm with -accel tcg,thread=multi
        if [ "$prev_arg" = "-accel" ] && [ "$arg" = "kvm" ]; then
          echo "Replaced -accel kvm with -accel tcg,thread=multi" >> /tmp/qemu-debug.log
          escaped=$(printf '%s' "tcg,thread=multi" | sed "s/'/'\\\\''/g")
          new_args="$new_args '$escaped'"
        # If current arg is -m, add it and mark to skip next value (replace with 16G)
        elif [ "$arg" = "-m" ]; then
          echo "Found -m argument, will replace value with 16G" >> /tmp/qemu-debug.log
          escaped=$(printf '%s' "$arg" | sed "s/'/'\\\\''/g")
          new_args="$new_args '$escaped' '16G'"
          skip_next=true
          skip_reason="-m"
        # If current arg is -machine, add it and mark to skip next value (replace with virt)
        elif [ "$arg" = "-machine" ]; then
          echo "Found -machine argument, will replace value with virt" >> /tmp/qemu-debug.log
          escaped=$(printf '%s' "$arg" | sed "s/'/'\\\\''/g")
          new_args="$new_args '$escaped' 'virt'"
          skip_next=true
          skip_reason="-machine"
        # If current arg is -cpu, add it and mark to skip next value (replace with max)
        elif [ "$arg" = "-cpu" ]; then
          echo "Found -cpu argument, will replace value with max (TCG needs explicit CPU)" >> /tmp/qemu-debug.log
          escaped=$(printf '%s' "$arg" | sed "s/'/'\\\\''/g")
          new_args="$new_args '$escaped' 'max'"
          skip_next=true
          skip_reason="-cpu"
        else
          # Properly quote and add all other arguments (including -initrd, which melange handles)
          escaped=$(printf '%s' "$arg" | sed "s/'/'\\\\''/g")
          new_args="$new_args '$escaped'"
        fi

        prev_arg="$arg"
      done

      echo "Final command: /usr/bin/qemu-system-aarch64.real $new_args" >> /tmp/qemu-debug.log

      # Execute with eval to properly handle quoted arguments
      eval exec /usr/bin/qemu-system-aarch64.real $new_args
      EOF

      chmod +x /usr/bin/qemu-system-aarch64
      echo "QEMU wrapper installed - will use TCG instead of KVM"

  # Setup kernel and extract virtio modules for melange
  setup_kernel_script:
    - |
      echo "=========================================="
      echo "SETUP KERNEL SCRIPT STARTING"
      echo "=========================================="
      
      # QEMU runner requires kernel and initramfs from linux-virt package
      KERNEL_PATH="/boot/vmlinuz-virt"
      INITRAMFS_PATH="/boot/initramfs-virt"
      
      echo "Checking for kernel and initramfs..."
      
      if [ ! -f "$KERNEL_PATH" ]; then
        echo "ERROR: Kernel not found at $KERNEL_PATH"
        ls -lh /boot/
        exit 1
      fi
      if [ ! -f "$INITRAMFS_PATH" ]; then
        echo "ERROR: Initramfs not found at $INITRAMFS_PATH"
        ls -lh /boot/
        exit 1
      fi
      
      echo "Kernel available at: $KERNEL_PATH"
      echo "Initramfs available at: $INITRAMFS_PATH"
      
      # Extract virtio modules from Alpine's initramfs
      # Melange will inject these into its own initramfs using QEMU_KERNEL_MODULES
      echo "Extracting virtio modules from Alpine initramfs..."
      MODULES_DIR="/tmp/virtio-modules"
      mkdir -p "$MODULES_DIR"
      
      # Extract initramfs (handle both compressed and uncompressed)
      if file "$INITRAMFS_PATH" | grep -q gzip; then
        echo "  Initramfs is gzip compressed, extracting..."
        gunzip -c "$INITRAMFS_PATH" > /tmp/alpine-initramfs.cpio
      else
        echo "  Initramfs is uncompressed, copying..."
        cp "$INITRAMFS_PATH" /tmp/alpine-initramfs.cpio
      fi
      
      # Extract modules from cpio archive
      cd "$MODULES_DIR"
      echo "  Extracting cpio archive..."
      if ! cpio -idm < /tmp/alpine-initramfs.cpio 2>&1 | head -20; then
        echo "ERROR: Failed to extract modules from cpio archive"
        echo "Debug: Checking if cpio archive is valid..."
        file /tmp/alpine-initramfs.cpio
        exit 1
      fi
      echo "  Extraction complete. Checking what was extracted..."
      
      # Find kernel version
      KERNEL_VERSION=$(ls lib/modules/ 2>/dev/null | head -1)
      if [ -n "$KERNEL_VERSION" ]; then
        echo "  Found kernel version: $KERNEL_VERSION"
        MODULES_BASE_PATH="$MODULES_DIR/lib/modules/$KERNEL_VERSION"
        echo "  Modules extracted to: $MODULES_BASE_PATH"
        
        # Verify extraction worked
        echo "  Verifying module structure:"
        ls -la lib/modules/ 2>/dev/null | head -5 || echo "    ERROR: lib/modules/ not found"
        
        # List virtio modules found
        echo "  Searching for virtio modules..."
        echo "  Full directory structure in lib/modules/$KERNEL_VERSION:"
        find lib/modules/$KERNEL_VERSION -type d 2>/dev/null | head -30 || true
        
        echo "  All .ko files found:"
        find lib/modules/$KERNEL_VERSION -name "*.ko" 2>/dev/null | head -20 || true
        
        # Find all virtio modules (they may be compressed as .ko.gz)
        echo "  Searching for virtio modules (including compressed .ko.gz files)..."
        VIRTIO_MODULES=$(find lib/modules/$KERNEL_VERSION -name "*virtio*.ko*" -type f 2>/dev/null)
        VIRTIO_COUNT=$(echo "$VIRTIO_MODULES" | grep -c . || echo "0")
        
        if [ "$VIRTIO_COUNT" -gt 0 ]; then
          echo "  ✓ Found $VIRTIO_COUNT virtio module(s) in initramfs:"
          echo "$VIRTIO_MODULES" | head -15
          
          # Create virtio directory and copy/decompress all virtio modules
          echo "  Preparing virtio modules directory..."
          mkdir -p lib/modules/$KERNEL_VERSION/kernel/drivers/virtio
          
          # Copy and decompress all virtio modules to the virtio directory
          echo "$VIRTIO_MODULES" | while read -r module_path; do
            if [ -n "$module_path" ]; then
              module_name=$(basename "$module_path")
              # Remove .gz extension if present
              target_name="${module_name%.gz}"
              target_path="lib/modules/$KERNEL_VERSION/kernel/drivers/virtio/$target_name"
              
              if echo "$module_name" | grep -q "\.gz$"; then
                echo "    Decompressing $module_name -> $target_name"
                gunzip -c "$module_path" > "$target_path" 2>/dev/null || cp "$module_path" "$target_path"
              else
                echo "    Copying $module_name"
                cp "$module_path" "$target_path" 2>/dev/null || true
              fi
            fi
          done
          
          # Verify decompressed modules
          echo "  Verifying decompressed virtio modules:"
          find lib/modules/$KERNEL_VERSION/kernel/drivers/virtio -name "*.ko" -type f 2>/dev/null | head -10
          VIRTIO_COUNT=$(find lib/modules/$KERNEL_VERSION/kernel/drivers/virtio -name "*.ko" -type f 2>/dev/null | wc -l)
          echo "  Total decompressed virtio modules: $VIRTIO_COUNT"
        else
          echo "  ⚠ WARNING: No virtio modules found in initramfs!"
          echo "  Checking if virtio modules are available in installed system..."
          if [ -d "/lib/modules/$KERNEL_VERSION" ]; then
            echo "  System modules directory exists, searching:"
            SYSTEM_VIRTIO=$(find /lib/modules/$KERNEL_VERSION -name '*virtio*.ko*' -type f 2>/dev/null | head -5)
            if [ -n "$SYSTEM_VIRTIO" ]; then
              echo "  ✓ Found virtio modules in system:"
              echo "$SYSTEM_VIRTIO"
              echo "  Copying virtio modules from system..."
              mkdir -p lib/modules/$KERNEL_VERSION/kernel/drivers/virtio
              echo "$SYSTEM_VIRTIO" | while read -r module_path; do
                if [ -n "$module_path" ]; then
                  module_name=$(basename "$module_path")
                  target_name="${module_name%.gz}"
                  if echo "$module_name" | grep -q "\.gz$"; then
                    gunzip -c "$module_path" > "lib/modules/$KERNEL_VERSION/kernel/drivers/virtio/$target_name" 2>/dev/null
                  else
                    cp "$module_path" "lib/modules/$KERNEL_VERSION/kernel/drivers/virtio/" 2>/dev/null
                  fi
                fi
              done
              VIRTIO_COUNT=$(find lib/modules/$KERNEL_VERSION/kernel/drivers/virtio -name "*.ko" -type f 2>/dev/null | wc -l)
              echo "  Total virtio modules after copy: $VIRTIO_COUNT"
            else
              echo "  ✗ No virtio modules found in system either"
              echo "  This is a problem - virtio modules are required for QEMU to work!"
            fi
          else
            echo "  ✗ System modules directory /lib/modules/$KERNEL_VERSION does not exist"
          fi
        fi
        
        # Check for modules.dep and other module metadata files
        if [ -f "lib/modules/$KERNEL_VERSION/modules.dep" ]; then
          echo "  ✓ modules.dep found"
        else
          echo "  ⚠ WARNING: modules.dep not found (modprobe may have issues)"
        fi
        
        # Melange constructs paths as: "/lib/modules/" + path[len(modulesPath):]
        # Pass modulesPath as /tmp/virtio-modules/lib/modules (without kernel version)
        # Then path[len(modulesPath):] = /6.12.58-0-virt/kernel/drivers/virtio/virtio_blk.ko
        # and header.Name = /lib/modules/6.12.58-0-virt/kernel/drivers/virtio/virtio_blk.ko (CORRECT)
        MODULES_PATH_FOR_MELANGE="$MODULES_DIR/lib/modules"
        echo "export QEMU_KERNEL_IMAGE=$KERNEL_PATH" >> $CIRRUS_ENV
        echo "export QEMU_KERNEL_MODULES=$MODULES_PATH_FOR_MELANGE" >> $CIRRUS_ENV
        echo "QEMU_KERNEL_MODULES set to: $MODULES_PATH_FOR_MELANGE (contains $KERNEL_VERSION subdirectory)"
        echo "  Full path structure: $MODULES_PATH_FOR_MELANGE/$KERNEL_VERSION/kernel/drivers/virtio/"
        
        # Verify the path exists and is accessible
        if [ ! -d "$MODULES_PATH_FOR_MELANGE" ]; then
          echo "ERROR: MODULES_PATH_FOR_MELANGE directory does not exist: $MODULES_PATH_FOR_MELANGE"
          exit 1
        fi
        echo "  ✓ MODULES_PATH_FOR_MELANGE directory exists and is accessible"
        
        # Show what melange will see
        echo "  Melange will process modules from: $MODULES_PATH_FOR_MELANGE"
        echo "  Example module path melange will create: /lib/modules/$KERNEL_VERSION/kernel/drivers/virtio/virtio_blk.ko"
      else
        echo "WARNING: Could not determine kernel version from initramfs"
        echo "export QEMU_KERNEL_IMAGE=$KERNEL_PATH" >> $CIRRUS_ENV
      fi
      
      # Cleanup temporary files
      rm -f /tmp/alpine-initramfs.cpio

  # Setup signing keys
  setup_keys_script:
    - |
      printf '%s\n' "$APK_SIGNING_KEY" > melange-pkcs8.rsa
      openssl rsa -in melange-pkcs8.rsa -out melange.rsa -traditional
      openssl rsa -in melange.rsa -pubout > melange.rsa.pub
      rm melange-pkcs8.rsa
      wget -q -O wolfi-signing.rsa.pub https://packages.wolfi.dev/os/wolfi-signing.rsa.pub

  # Build stremio-server (Node.js package, no compilation needed)
  build_script:
    - mkdir -p build-output/aarch64 build-output/logs
    - |
      # Source environment variables from CIRRUS_ENV if it exists
      if [ -f "$CIRRUS_ENV" ]; then
        echo "Loading environment variables from $CIRRUS_ENV:"
        cat "$CIRRUS_ENV"
        set -a
        source "$CIRRUS_ENV"
        set +a
      fi
      
      # Set default kernel image if not already set
      export QEMU_KERNEL_IMAGE=${QEMU_KERNEL_IMAGE:-/boot/vmlinuz-virt}
      
      echo "Build environment:"
      echo "  QEMU_KERNEL_IMAGE=$QEMU_KERNEL_IMAGE"
      echo "  QEMU_KERNEL_MODULES=${QEMU_KERNEL_MODULES:-NOT SET}"
      
      if [ -n "$QEMU_KERNEL_MODULES" ]; then
        export QEMU_KERNEL_MODULES
        echo "Using QEMU_KERNEL_MODULES=$QEMU_KERNEL_MODULES"
        if [ -d "$QEMU_KERNEL_MODULES" ]; then
          echo "  ✓ QEMU_KERNEL_MODULES directory exists"
          ls -la "$QEMU_KERNEL_MODULES" | head -5
        else
          echo "  ✗ ERROR: QEMU_KERNEL_MODULES directory does not exist: $QEMU_KERNEL_MODULES"
        fi
      else
        echo "WARNING: QEMU_KERNEL_MODULES not set - virtio modules may not be available"
      fi
      melange build \
        --runner qemu \
        --arch aarch64 \
        --signing-key melange.rsa \
        --keyring-append melange.rsa.pub \
        --keyring-append wolfi-signing.rsa.pub \
        --repository-append https://packages.wolfi.dev/os \
        --pipeline-dir pipelines \
        --out-dir build-output/aarch64 \
        packages/stremio-server.yaml || true
    - ls -lh build-output/aarch64/ || true
    - cp /tmp/qemu-debug.log build-output/logs/ || echo "No QEMU debug log found"

  # Upload artifacts
  always:
    apk_packages_artifacts:
      path: "build-output/aarch64/*.apk"
    qemu_logs_artifacts:
      path: "build-output/logs/qemu-debug.log"
