name: Sign and Publish APK Repository

on:
  workflow_run:
    workflows: ["Build Wolfi APK Packages"]
    types:
      - completed
    branches:
      - master
  workflow_dispatch:
    inputs:
      run_id:
        description: 'Build workflow run ID (leave empty for latest successful build)'
        required: false
        type: string
      force_publish:
        description: 'Force publish (ignore build status)'
        required: false
        default: 'false'
        type: boolean
      incremental:
        description: 'Incremental publish (merge with existing packages from SourceForge)'
        required: false
        default: 'false'
        type: boolean

permissions:
  contents: read
  actions: read

jobs:
  sign-and-publish:
    name: Sign and Publish to SourceForge
    runs-on: ubuntu-latest
    # Always run when:
    # 1. Build workflow completes (success or failure with artifacts), OR
    # 2. Manually triggered (workflow_dispatch)
    # This allows uploading successful packages even if some packages in the build failed
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event.workflow_run.conclusion == 'success' || github.event.workflow_run.conclusion == 'failure') }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install required tools
        run: |
          sudo apt-get update
          sudo apt-get install -y lftp openssh-client tree

      - name: Get build run ID
        id: get-run-id
        run: |
          if [ -n "${{ github.event.inputs.run_id }}" ]; then
            echo "run_id=${{ github.event.inputs.run_id }}" >> $GITHUB_OUTPUT
          elif [ -n "${{ github.event.workflow_run.id }}" ]; then
            echo "run_id=${{ github.event.workflow_run.id }}" >> $GITHUB_OUTPUT
          else
            # Get latest successful build run
            RUN_ID=$(gh run list -R ${{ github.repository }} --workflow=build-packages.yml --status=success --limit=1 --json databaseId --jq '.[0].databaseId')
            echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
          fi
          echo "Using build run ID: $(cat $GITHUB_OUTPUT | grep run_id | cut -d= -f2)"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Download build artifacts (GitHub Actions - x86_64)
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          path: build-artifacts
          run-id: ${{ steps.get-run-id.outputs.run_id }}
          github-token: ${{ github.token }}
          pattern: 'apk-packages-*'

      - name: Download Cirrus CI artifacts (aarch64)
        continue-on-error: true
        run: |
          echo "=== Downloading Cirrus CI aarch64 artifacts ==="

          # Create directory for Cirrus CI artifacts
          mkdir -p build-artifacts/cirrus-aarch64/aarch64

          # Query Cirrus CI GraphQL API to get the latest successful build
          # for the master/main branch
          CIRRUS_REPO_OWNER=$(echo "${{ github.repository }}" | cut -d/ -f1)
          CIRRUS_REPO_NAME=$(echo "${{ github.repository }}" | cut -d/ -f2)

          echo "Querying Cirrus CI for latest successful build on branch: ${{ github.ref_name }}"

          # GraphQL query to find the latest successful build with artifacts
          QUERY=$(cat <<'EOF'
          {
            ownerRepository(platform: "github", owner: "REPO_OWNER", name: "REPO_NAME") {
              builds(last: 10, branch: "BRANCH_NAME") {
                edges {
                  node {
                    id
                    status
                    tasks {
                      id
                      name
                      status
                      artifacts {
                        name
                        files {
                          path
                          size
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          EOF
          )

          # Replace placeholders
          QUERY=$(echo "$QUERY" | sed "s/REPO_OWNER/$CIRRUS_REPO_OWNER/g" | sed "s/REPO_NAME/$CIRRUS_REPO_NAME/g" | sed "s/BRANCH_NAME/${{ github.ref_name }}/g")

          # Query Cirrus CI API
          RESPONSE=$(curl -s -X POST https://api.cirrus-ci.com/graphql \
            -H "Content-Type: application/json" \
            -d "{\"query\": $(echo "$QUERY" | jq -Rs .)}")

          echo "Cirrus CI API response received"

          # Find the latest successful build with aarch64 artifacts
          BUILD_ID=$(echo "$RESPONSE" | jq -r '.data.ownerRepository.builds.edges[] | select(.node.status == "COMPLETED") | .node.id' | head -1)

          if [ -z "$BUILD_ID" ]; then
            echo "No completed Cirrus CI builds found"
            echo "This is expected if Cirrus CI hasn't run yet or builds are still in progress"
            exit 0
          fi

          echo "Found Cirrus CI build ID: $BUILD_ID"

          # Get artifact URLs from the build
          TASK_ID=$(echo "$RESPONSE" | jq -r ".data.ownerRepository.builds.edges[] | select(.node.id == \"$BUILD_ID\") | .node.tasks[0].id")

          if [ -z "$TASK_ID" ]; then
            echo "No tasks found in Cirrus CI build"
            exit 0
          fi

          echo "Downloading artifacts from task: $TASK_ID"

          # Download APK files directly from Cirrus CI
          # Artifact URL format: https://api.cirrus-ci.com/v1/artifact/task/{taskId}/{artifactPath}
          curl -f -L "https://api.cirrus-ci.com/v1/artifact/task/$TASK_ID/build-output/aarch64" -o cirrus-aarch64.tar.gz || {
            echo "Failed to download Cirrus CI artifacts - may not be available yet"
            exit 0
          }

          # Extract artifacts
          tar -xzf cirrus-aarch64.tar.gz -C build-artifacts/cirrus-aarch64/ || {
            echo "Warning: Failed to extract Cirrus CI artifacts"
            exit 0
          }

          APK_COUNT=$(find build-artifacts/cirrus-aarch64 -name '*.apk' | wc -l)
          echo "Downloaded $APK_COUNT aarch64 packages from Cirrus CI"

      - name: Download existing packages from SourceForge
        run: |
          echo "=== Downloading existing packages from SourceForge ==="
          echo "Ensuring APKINDEX includes all packages (new + existing)"

          # Create temp directory for existing packages
          mkdir -p existing-repo

          # Setup SSH for SourceForge download
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.SOURCEFORGE_SSH_KEY }}" > ~/.ssh/sourceforge_wolfi_rsa
          chmod 600 ~/.ssh/sourceforge_wolfi_rsa
          ssh-keyscan -H frs.sourceforge.net >> ~/.ssh/known_hosts

          # Create SSH config for lftp to use the correct identity file
          cat >> ~/.ssh/config << 'EOF'
          Host frs.sourceforge.net
              User jmendezr
              IdentityFile ~/.ssh/sourceforge_wolfi_rsa
              StrictHostKeyChecking no
          EOF
          chmod 600 ~/.ssh/config

          # Download existing packages using lftp (excludes APKINDEX - will regenerate)
          for arch in x86_64 aarch64; do
            echo "Downloading existing $arch packages..."
            mkdir -p existing-repo/$arch

            lftp -c "
              set ssl:verify-certificate no
              set net:timeout 60
              set net:max-retries 3
              open sftp://jmendezr@frs.sourceforge.net
              mirror --verbose --exclude-glob 'APKINDEX*' \
                /home/frs/project/wolfi/$arch/ existing-repo/$arch/
            " || echo "No existing packages for $arch (first publish?)"
          done

          echo ""
          echo "=== Downloaded packages summary ==="
          echo "x86_64: $(find existing-repo/x86_64 -name '*.apk' 2>/dev/null | wc -l) packages"
          echo "aarch64: $(find existing-repo/aarch64 -name '*.apk' 2>/dev/null | wc -l) packages"
          du -sh existing-repo/ 2>/dev/null || echo "No existing packages found"

      - name: Organize repository by architecture
        run: |
          echo "=== Organizing repository by architecture ==="

          # Create repository structure
          mkdir -p repo/x86_64 repo/aarch64 repo/keys

          # Copy existing packages first (always, to ensure APKINDEX completeness)
          echo "Copying existing packages to merge with new build..."
          for arch in x86_64 aarch64; do
            if [ -d "existing-repo/$arch" ]; then
              echo "Copying existing $arch packages..."
              cp -v existing-repo/$arch/*.apk repo/$arch/ 2>/dev/null || echo "No existing $arch packages"
            fi
          done

          # Copy new APK packages (will overwrite older versions of same package)
          for arch in x86_64 aarch64; do
            echo "Processing new $arch artifacts..."

            # Find and copy APK files from build artifacts
            find build-artifacts -path "*${arch}*" -name "*.apk" -exec cp -v {} repo/$arch/ \;

            # Note: We don't copy APKINDEX from build artifacts or existing repo
            # Will regenerate fresh APKINDEX with all packages in next step
          done

          # Copy permanent signing public key from local file
          # Extract public key from GitHub Secrets (convert PKCS#8 to PKCS#1 first)
          echo "${{ secrets.APK_SIGNING_KEY }}" > /tmp/melange-pkcs8.rsa
          openssl rsa -in /tmp/melange-pkcs8.rsa -out /tmp/melange.rsa -traditional
          openssl rsa -in /tmp/melange.rsa -pubout > repo/keys/vejeta-wolfi.rsa.pub
          rm /tmp/melange-pkcs8.rsa /tmp/melange.rsa

          echo "Using permanent signing key public key (converted from PKCS#8)"
          ls -lh repo/keys/vejeta-wolfi.rsa.pub

          echo ""
          echo "=== Repository structure ==="
          tree -h repo/ || find repo/ -type f -exec ls -lh {} \;

      - name: Setup signing key for APKINDEX
        run: |
          echo "=== Preparing signing key for APKINDEX ==="

          # Extract and convert signing key from GitHub Secrets
          echo "${{ secrets.APK_SIGNING_KEY }}" > /tmp/melange-pkcs8.rsa
          openssl rsa -in /tmp/melange-pkcs8.rsa -out /tmp/melange.rsa -traditional
          chmod 600 /tmp/melange.rsa
          rm /tmp/melange-pkcs8.rsa

          echo "Signing key ready for APKINDEX signing"
          ls -lh /tmp/melange.rsa

      - name: Re-sign all packages and generate APKINDEX for each architecture
        run: |
          echo "=== Re-signing packages and generating APKINDEX ==="
          echo "This ensures all packages are signed with vejeta-wolfi.rsa for end-to-end verification"

          for arch in x86_64 aarch64; do
            echo "Checking $arch..."

            # Only process if there are APK packages
            if ls repo/$arch/*.apk 1> /dev/null 2>&1; then
              echo "Re-signing and indexing $arch packages..."

              # Copy signing key into arch directory for Docker access
              # Use vejeta-wolfi.rsa as filename so signature matches public key name
              cp /tmp/melange.rsa repo/$arch/vejeta-wolfi.rsa

              cd repo/$arch

              # Use Alpine container to:
              # 1. Re-sign ALL .apk files with vejeta-wolfi.rsa
              # 2. Generate APKINDEX with all packages
              # 3. Sign APKINDEX with vejeta-wolfi.rsa
              docker run --rm \
                -v $PWD:/packages \
                -w /packages \
                alpine:latest \
                sh -c "apk add --no-cache apk-tools abuild && \
                  echo '=== Re-signing all packages ===' && \
                  for apk in *.apk; do \
                    echo \"Re-signing \$apk...\" && \
                    abuild-sign -k /packages/vejeta-wolfi.rsa \"\$apk\"; \
                  done && \
                  echo '=== Generating APKINDEX ===' && \
                  apk index --allow-untrusted -o APKINDEX.tar.gz *.apk && \
                  echo '=== Signing APKINDEX ===' && \
                  abuild-sign -k /packages/vejeta-wolfi.rsa APKINDEX.tar.gz && \
                  ls -lh APKINDEX.tar.gz"

              # Remove signing key from repo directory (security)
              rm vejeta-wolfi.rsa

              cd ../..

              echo "Packages re-signed and APKINDEX generated for $arch"
            else
              echo "No packages found for $arch, skipping"
            fi
          done

          echo ""
          echo "=== APKINDEX files created and signed ==="
          ls -lh repo/*/APKINDEX.tar.gz 2>/dev/null || echo "No APKINDEX files generated"

          # Verify signature files are present in APKINDEX archives
          echo ""
          echo "=== Verifying APKINDEX signatures ==="
          for arch in x86_64 aarch64; do
            if [ -f "repo/$arch/APKINDEX.tar.gz" ]; then
              echo "Contents of $arch APKINDEX.tar.gz:"
              tar -tzf "repo/$arch/APKINDEX.tar.gz"
            fi
          done

      - name: Verify repository structure
        run: |
          echo "=== Final repository structure ==="
          tree -h repo/ || find repo/ -type f -exec ls -lh {} \;

          echo ""
          echo "=== Package count ==="
          echo "x86_64: $(find repo/x86_64 -name "*.apk" | wc -l) packages"
          echo "aarch64: $(find repo/aarch64 -name "*.apk" | wc -l) packages"

          echo ""
          echo "=== Verify APKINDEX exists ==="
          ls -lh repo/x86_64/APKINDEX.tar.gz repo/aarch64/APKINDEX.tar.gz || echo "Warning: APKINDEX files not found"

          echo ""
          echo "=== Total repository size ==="
          du -sh repo/

      - name: Setup SSH for SourceForge
        run: |
          # Create .ssh directory
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          # Add SourceForge SSH key
          echo "${{ secrets.SOURCEFORGE_SSH_KEY }}" > ~/.ssh/sourceforge_wolfi_rsa
          chmod 600 ~/.ssh/sourceforge_wolfi_rsa

          # Add SourceForge to known hosts
          ssh-keyscan -H frs.sourceforge.net >> ~/.ssh/known_hosts
          ssh-keyscan -H web.sourceforge.net >> ~/.ssh/known_hosts

          # Create SSH config for SourceForge (lftp uses SSH config)
          cat >> ~/.ssh/config << 'EOF'
          Host frs.sourceforge.net
              User jmendezr
              IdentityFile ~/.ssh/sourceforge_wolfi_rsa
              StrictHostKeyChecking no
          EOF
          chmod 600 ~/.ssh/config

          echo "SSH configured for SourceForge with lftp support"

      - name: Sync to SourceForge
        run: |
          echo "=== Syncing repository to SourceForge ==="

          chmod +x scripts/sync-sourceforge.sh

          ./scripts/sync-sourceforge.sh \
            repo/ \
            jmendezr@frs.sourceforge.net:/home/frs/project/wolfi/

          echo "Repository published to SourceForge successfully!"

      - name: Create deployment summary
        run: |
          cat > deployment-summary.md << 'EOF'
          # Wolfi APK Repository Deployment Summary

          ## Repository Information

          **SourceForge URL**: https://sourceforge.net/projects/wolfi/files/

          ## Installation Instructions

          ### For Wolfi Linux users:

          ```bash
          # Add repository signing key
          wget -O /etc/apk/keys/vejeta-wolfi.rsa.pub \
            https://sourceforge.net/projects/wolfi/files/keys/vejeta-wolfi.rsa.pub

          # Add repository to /etc/apk/repositories
          echo "https://downloads.sourceforge.net/project/wolfi/repo/$(uname -m)" >> /etc/apk/repositories

          # Update package index
          apk update

          # Install packages
          apk add stremio mpv qt5-qtwebengine
          ```

          ## Package Statistics

          - **x86_64 packages**: $(find repo/x86_64 -name "*.apk" | wc -l)
          - **aarch64 packages**: $(find repo/aarch64 -name "*.apk" | wc -l)
          - **Total size**: $(du -sh repo/ | cut -f1)

          ## Build Information

          - **Workflow**: ${{ github.workflow }}
          - **Run ID**: ${{ github.run_id }}
          - **Commit**: ${{ github.sha }}
          - **Date**: $(date -u +"%Y-%m-%d %H:%M UTC")

          EOF

          cat deployment-summary.md

      - name: Upload deployment summary
        uses: actions/upload-artifact@v4
        with:
          name: deployment-summary
          path: deployment-summary.md
          retention-days: 90

  notify-deployment:
    name: Notify Deployment Status
    needs: sign-and-publish
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Deployment Status
        run: |
          if [ "${{ needs.sign-and-publish.result }}" == "success" ]; then
            echo "Repository successfully deployed to SourceForge!"
            echo "Users can now install packages from: https://sourceforge.net/projects/wolfi/files/"
          else
            echo "Deployment failed. Check logs above for details."
            exit 1
          fi
