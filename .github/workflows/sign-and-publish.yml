name: Sign and Publish APK Repository

on:
  workflow_run:
    workflows: ["Build Wolfi APK Packages"]
    types:
      - completed
    branches:
      - master
  workflow_dispatch:
    inputs:
      run_id:
        description: 'Build workflow run ID (leave empty for latest successful build)'
        required: false
        type: string
      force_publish:
        description: 'Force publish (ignore build status)'
        required: false
        default: 'false'
        type: boolean
      incremental:
        description: 'Incremental publish (merge with existing packages from SourceForge)'
        required: false
        default: 'false'
        type: boolean

permissions:
  contents: read
  actions: read

jobs:
  sign-and-publish:
    name: Sign and Publish to SourceForge
    runs-on: ubuntu-latest
    # Always run when:
    # 1. Build workflow completes (success or failure with artifacts), OR
    # 2. Manually triggered (workflow_dispatch)
    # This allows uploading successful packages even if some packages in the build failed
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event.workflow_run.conclusion == 'success' || github.event.workflow_run.conclusion == 'failure') }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install required tools
        run: |
          sudo apt-get update
          sudo apt-get install -y lftp openssh-client tree

      - name: Get build run ID
        id: get-run-id
        run: |
          if [ -n "${{ github.event.inputs.run_id }}" ]; then
            echo "run_id=${{ github.event.inputs.run_id }}" >> $GITHUB_OUTPUT
          elif [ -n "${{ github.event.workflow_run.id }}" ]; then
            echo "run_id=${{ github.event.workflow_run.id }}" >> $GITHUB_OUTPUT
          else
            # Get latest successful build run
            RUN_ID=$(gh run list -R ${{ github.repository }} --workflow=build-packages.yml --status=success --limit=1 --json databaseId --jq '.[0].databaseId')
            echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
          fi
          echo "Using build run ID: $(cat $GITHUB_OUTPUT | grep run_id | cut -d= -f2)"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Download build artifacts (GitHub Actions - x86_64)
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          path: build-artifacts
          run-id: ${{ steps.get-run-id.outputs.run_id }}
          github-token: ${{ github.token }}
          pattern: 'apk-packages-*'

      - name: Check for Cirrus CI aarch64 artifacts
        id: check-cirrus
        continue-on-error: true
        run: |
          echo "=== Checking for Cirrus CI aarch64 builds ==="

          # Get the latest Cirrus CI build for this repository
          # Cirrus CI artifacts are uploaded via GitHub Checks API
          # We'll check if there are recent successful Cirrus CI builds

          CIRRUS_BUILD=$(gh api repos/${{ github.repository }}/commits/${{ github.sha }}/check-runs \
            --jq '.check_runs[] | select(.app.slug == "cirrus-ci") | select(.conclusion == "success") | .id' \
            | head -1 || echo "")

          if [ -n "$CIRRUS_BUILD" ]; then
            echo "cirrus_available=true" >> $GITHUB_OUTPUT
            echo "Found Cirrus CI build: $CIRRUS_BUILD"
          else
            echo "cirrus_available=false" >> $GITHUB_OUTPUT
            echo "No Cirrus CI aarch64 builds found for this commit"
            echo "This is expected if Cirrus CI hasn't run yet or if building x86_64 only"
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Download Cirrus CI artifacts (aarch64)
        if: steps.check-cirrus.outputs.cirrus_available == 'true'
        continue-on-error: true
        run: |
          echo "=== Downloading Cirrus CI aarch64 artifacts ==="

          # Create directory for Cirrus CI artifacts
          mkdir -p build-artifacts/cirrus-aarch64/aarch64

          # Cirrus CI uploads artifacts to GitHub via artifacts API
          # Try to find and download apk-packages-aarch64 artifact
          CIRRUS_ARTIFACT_ID=$(gh api repos/${{ github.repository }}/actions/artifacts \
            --jq '.artifacts[] | select(.name == "apk-packages-aarch64") | select(.expired == false) | .id' \
            | head -1 || echo "")

          if [ -n "$CIRRUS_ARTIFACT_ID" ]; then
            echo "Found Cirrus CI aarch64 artifact ID: $CIRRUS_ARTIFACT_ID"
            gh api repos/${{ github.repository }}/actions/artifacts/$CIRRUS_ARTIFACT_ID/zip > cirrus-aarch64.zip
            unzip -q cirrus-aarch64.zip -d build-artifacts/cirrus-aarch64/
            echo "Downloaded $(find build-artifacts/cirrus-aarch64 -name '*.apk' | wc -l) aarch64 packages from Cirrus CI"
          else
            echo "No Cirrus CI aarch64 artifacts found (may not have uploaded yet)"
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Download existing packages from SourceForge (incremental mode)
        if: ${{ github.event.inputs.incremental == 'true' }}
        run: |
          echo "=== Downloading existing packages from SourceForge ==="
          echo "Incremental mode enabled - will merge with existing repository"

          # Create temp directory for existing packages
          mkdir -p existing-repo

          # Setup SSH for SourceForge download
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.SOURCEFORGE_SSH_KEY }}" > ~/.ssh/sourceforge_wolfi_rsa
          chmod 600 ~/.ssh/sourceforge_wolfi_rsa
          ssh-keyscan -H frs.sourceforge.net >> ~/.ssh/known_hosts

          # Download existing packages using lftp (excludes APKINDEX - will regenerate)
          for arch in x86_64 aarch64; do
            echo "Downloading existing $arch packages..."
            mkdir -p existing-repo/$arch

            lftp -c "
              set ssl:verify-certificate no
              set net:timeout 60
              set net:max-retries 3
              open sftp://jmendezr@frs.sourceforge.net
              mirror --verbose --exclude-glob 'APKINDEX*' \
                /home/frs/project/wolfi/$arch/ existing-repo/$arch/
            " || echo "No existing packages for $arch (first publish?)"
          done

          echo ""
          echo "=== Downloaded packages summary ==="
          echo "x86_64: $(find existing-repo/x86_64 -name '*.apk' 2>/dev/null | wc -l) packages"
          echo "aarch64: $(find existing-repo/aarch64 -name '*.apk' 2>/dev/null | wc -l) packages"
          du -sh existing-repo/ 2>/dev/null || echo "No existing packages found"

      - name: Organize repository by architecture
        run: |
          echo "=== Organizing repository by architecture ==="

          # Create repository structure
          mkdir -p repo/x86_64 repo/aarch64 repo/keys

          # Copy existing packages first (if incremental mode)
          if [ "${{ github.event.inputs.incremental }}" == "true" ]; then
            echo "Incremental mode: copying existing packages first..."
            for arch in x86_64 aarch64; do
              if [ -d "existing-repo/$arch" ]; then
                echo "Copying existing $arch packages..."
                cp -v existing-repo/$arch/*.apk repo/$arch/ 2>/dev/null || echo "No existing $arch packages"
              fi
            done
          fi

          # Copy new APK packages (will overwrite older versions of same package)
          for arch in x86_64 aarch64; do
            echo "Processing new $arch artifacts..."

            # Find and copy APK files from build artifacts
            find build-artifacts -path "*${arch}*" -name "*.apk" -exec cp -v {} repo/$arch/ \;

            # Note: We don't copy APKINDEX from build artifacts or existing repo
            # Will regenerate fresh APKINDEX with all packages in next step
          done

          # Copy permanent signing public key from local file
          # Extract public key from GitHub Secrets (convert PKCS#8 to PKCS#1 first)
          echo "${{ secrets.APK_SIGNING_KEY }}" > /tmp/melange-pkcs8.rsa
          openssl rsa -in /tmp/melange-pkcs8.rsa -out /tmp/melange.rsa -traditional
          openssl rsa -in /tmp/melange.rsa -pubout > repo/keys/vejeta-wolfi.rsa.pub
          rm /tmp/melange-pkcs8.rsa /tmp/melange.rsa

          echo "Using permanent signing key public key (converted from PKCS#8)"
          ls -lh repo/keys/vejeta-wolfi.rsa.pub

          echo ""
          echo "=== Repository structure ==="
          tree -h repo/ || find repo/ -type f -exec ls -lh {} \;

      - name: Setup signing key for APKINDEX
        run: |
          echo "=== Preparing signing key for APKINDEX ==="

          # Extract and convert signing key from GitHub Secrets
          echo "${{ secrets.APK_SIGNING_KEY }}" > /tmp/melange-pkcs8.rsa
          openssl rsa -in /tmp/melange-pkcs8.rsa -out /tmp/melange.rsa -traditional
          chmod 600 /tmp/melange.rsa
          rm /tmp/melange-pkcs8.rsa

          echo "Signing key ready for APKINDEX signing"
          ls -lh /tmp/melange.rsa

      - name: Generate and sign APKINDEX for each architecture
        run: |
          echo "=== Generating and signing APKINDEX ==="

          for arch in x86_64 aarch64; do
            echo "Checking $arch..."

            # Only generate APKINDEX if there are APK packages
            if ls repo/$arch/*.apk 1> /dev/null 2>&1; then
              echo "Generating APKINDEX for $arch..."

              # Copy signing key into arch directory for Docker access
              # Use vejeta-wolfi.rsa as filename so signature matches public key name
              cp /tmp/melange.rsa repo/$arch/vejeta-wolfi.rsa

              cd repo/$arch

              # Use Alpine container to generate and SIGN APKINDEX
              docker run --rm \
                -v $PWD:/packages \
                -w /packages \
                alpine:latest \
                sh -c "apk add --no-cache apk-tools abuild && \
                  apk index --allow-untrusted -o APKINDEX.tar.gz *.apk && \
                  abuild-sign -k /packages/vejeta-wolfi.rsa APKINDEX.tar.gz && \
                  ls -lh APKINDEX.tar.gz"

              # Remove signing key from repo directory (security)
              rm vejeta-wolfi.rsa

              cd ../..

              echo "APKINDEX for $arch generated and signed successfully"
            else
              echo "No packages found for $arch, skipping APKINDEX generation"
            fi
          done

          echo ""
          echo "=== APKINDEX files created and signed ==="
          ls -lh repo/*/APKINDEX.tar.gz 2>/dev/null || echo "No APKINDEX files generated"

          # Verify signature files are present in APKINDEX archives
          echo ""
          echo "=== Verifying APKINDEX signatures ==="
          for arch in x86_64 aarch64; do
            if [ -f "repo/$arch/APKINDEX.tar.gz" ]; then
              echo "Contents of $arch APKINDEX.tar.gz:"
              tar -tzf "repo/$arch/APKINDEX.tar.gz"
            fi
          done

      - name: Verify repository structure
        run: |
          echo "=== Final repository structure ==="
          tree -h repo/ || find repo/ -type f -exec ls -lh {} \;

          echo ""
          echo "=== Package count ==="
          echo "x86_64: $(find repo/x86_64 -name "*.apk" | wc -l) packages"
          echo "aarch64: $(find repo/aarch64 -name "*.apk" | wc -l) packages"

          echo ""
          echo "=== Verify APKINDEX exists ==="
          ls -lh repo/x86_64/APKINDEX.tar.gz repo/aarch64/APKINDEX.tar.gz || echo "Warning: APKINDEX files not found"

          echo ""
          echo "=== Total repository size ==="
          du -sh repo/

      - name: Setup SSH for SourceForge
        run: |
          # Create .ssh directory
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          # Add SourceForge SSH key
          echo "${{ secrets.SOURCEFORGE_SSH_KEY }}" > ~/.ssh/sourceforge_wolfi_rsa
          chmod 600 ~/.ssh/sourceforge_wolfi_rsa

          # Add SourceForge to known hosts
          ssh-keyscan -H frs.sourceforge.net >> ~/.ssh/known_hosts
          ssh-keyscan -H web.sourceforge.net >> ~/.ssh/known_hosts

          # Create SSH config for SourceForge (lftp uses SSH config)
          cat >> ~/.ssh/config << 'EOF'
          Host frs.sourceforge.net
              User jmendezr
              IdentityFile ~/.ssh/sourceforge_wolfi_rsa
              StrictHostKeyChecking no
          EOF
          chmod 600 ~/.ssh/config

          echo "SSH configured for SourceForge with lftp support"

      - name: Sync to SourceForge
        run: |
          echo "=== Syncing repository to SourceForge ==="

          chmod +x scripts/sync-sourceforge.sh

          ./scripts/sync-sourceforge.sh \
            repo/ \
            jmendezr@frs.sourceforge.net:/home/frs/project/wolfi/

          echo "Repository published to SourceForge successfully!"

      - name: Create deployment summary
        run: |
          cat > deployment-summary.md << 'EOF'
          # Wolfi APK Repository Deployment Summary

          ## Repository Information

          **SourceForge URL**: https://sourceforge.net/projects/wolfi/files/

          ## Installation Instructions

          ### For Wolfi Linux users:

          ```bash
          # Add repository signing key
          wget -O /etc/apk/keys/vejeta-wolfi.rsa.pub \
            https://sourceforge.net/projects/wolfi/files/keys/vejeta-wolfi.rsa.pub

          # Add repository to /etc/apk/repositories
          echo "https://downloads.sourceforge.net/project/wolfi/repo/$(uname -m)" >> /etc/apk/repositories

          # Update package index
          apk update

          # Install packages
          apk add stremio mpv qt5-qtwebengine
          ```

          ## Package Statistics

          - **x86_64 packages**: $(find repo/x86_64 -name "*.apk" | wc -l)
          - **aarch64 packages**: $(find repo/aarch64 -name "*.apk" | wc -l)
          - **Total size**: $(du -sh repo/ | cut -f1)

          ## Build Information

          - **Workflow**: ${{ github.workflow }}
          - **Run ID**: ${{ github.run_id }}
          - **Commit**: ${{ github.sha }}
          - **Date**: $(date -u +"%Y-%m-%d %H:%M UTC")

          EOF

          cat deployment-summary.md

      - name: Upload deployment summary
        uses: actions/upload-artifact@v4
        with:
          name: deployment-summary
          path: deployment-summary.md
          retention-days: 90

  notify-deployment:
    name: Notify Deployment Status
    needs: sign-and-publish
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Deployment Status
        run: |
          if [ "${{ needs.sign-and-publish.result }}" == "success" ]; then
            echo "Repository successfully deployed to SourceForge!"
            echo "Users can now install packages from: https://sourceforge.net/projects/wolfi/files/"
          else
            echo "Deployment failed. Check logs above for details."
            exit 1
          fi
