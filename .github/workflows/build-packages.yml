name: Build Wolfi APK Packages

on:
  push:
    tags:
      - 'v*'
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      package_filter:
        description: 'Build specific packages (comma-separated, e.g. "libass,zlib" or leave empty for all)'
        required: false
        default: ''
        type: string
      architectures:
        description: 'Target architectures (comma-separated, e.g. "x86_64" or "x86_64,aarch64")'
        required: false
        default: 'x86_64'
        type: string

permissions:
  contents: read

env:
  MELANGE_VERSION: latest

jobs:
  prepare-build-matrix:
    name: Prepare Build Matrix
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.find-packages.outputs.packages }}
      architectures: ${{ steps.find-packages.outputs.architectures }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Find all package configurations
        id: find-packages
        run: |
          # Find all .yaml files in packages/ directory (flat structure like wolfi-os)
          packages=$(find packages -maxdepth 1 -name "*.yaml" -type f | sed 's|packages/||' | sed 's|\.yaml||' | sort -u | jq -R -s -c 'split("\n")[:-1]')

          # If package_filter is set, filter the list
          if [ -n "${{ github.event.inputs.package_filter }}" ]; then
            # Split comma-separated filter into array and match any
            filter_list=$(echo "${{ github.event.inputs.package_filter }}" | jq -R 'split(",")')
            packages=$(echo "$packages" | jq -c --argjson filters "$filter_list" '[.[] | select(. as $pkg | $filters | index($pkg))]')
          fi

          # Process architectures parameter (default: x86_64)
          ARCH_INPUT="${{ github.event.inputs.architectures }}"
          if [ -z "$ARCH_INPUT" ]; then
            ARCH_INPUT="x86_64"
          fi
          architectures=$(echo "$ARCH_INPUT" | jq -R -c 'split(",")')

          echo "packages=$packages" >> $GITHUB_OUTPUT
          echo "architectures=$architectures" >> $GITHUB_OUTPUT
          echo "Found packages:"
          echo "$packages" | jq .
          echo "Target architectures:"
          echo "$architectures" | jq .

  build-packages:
    name: Build ${{ matrix.package }} - ${{ matrix.arch }}
    needs: prepare-build-matrix
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        package: ${{ fromJson(needs.prepare-build-matrix.outputs.packages) }}
        arch: ${{ fromJson(needs.prepare-build-matrix.outputs.architectures) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up QEMU for multi-architecture builds
        uses: docker/setup-qemu-action@v3
        with:
          platforms: linux/amd64,linux/arm64

      - name: Restore package cache
        uses: actions/cache/restore@v4
        id: cache-restore
        with:
          path: ./package-cache/${{ matrix.arch }}
          key: wolfi-packages-consolidated-${{ matrix.arch }}-
          restore-keys: |
            wolfi-packages-consolidated-${{ matrix.arch }}-

      - name: Create build directories
        run: |
          mkdir -p ./build-output
          mkdir -p ./workspace
          mkdir -p ./package-cache/${{ matrix.arch }}

      - name: Generate Melange signing key
        run: |
          # Generate signing key using Melange container
          docker run --rm \
            -v $PWD:/work \
            -w /work \
            cgr.dev/chainguard/melange:latest \
            keygen

          # Download official Wolfi signing key for repository verification
          curl -o wolfi-signing.rsa.pub https://packages.wolfi.dev/os/wolfi-signing.rsa.pub

          # Verify keys were created
          ls -lh melange.rsa melange.rsa.pub wolfi-signing.rsa.pub

          # Fix permissions (files created by container are owned by root)
          sudo chown $(id -u):$(id -g) melange.rsa melange.rsa.pub
          chmod 600 melange.rsa
          chmod 644 melange.rsa.pub wolfi-signing.rsa.pub

      - name: Setup package cache as local repository
        run: |
          echo "=== Checking package cache ==="
          CACHE_PKG_COUNT=$(find ./package-cache/${{ matrix.arch }} -name "*.apk" 2>/dev/null | wc -l || echo "0")
          echo "Found $CACHE_PKG_COUNT packages in GitHub Actions cache"

          if [ "$CACHE_PKG_COUNT" -gt 0 ]; then
            echo "Using cached packages from previous builds"
            cd ./package-cache/${{ matrix.arch }}

            # Generate APKINDEX for cached packages
            docker run --rm \
              -v $PWD:/work \
              -w /work \
              alpine:latest \
              sh -c "apk add --no-cache apk-tools abuild && \
                apk index --allow-untrusted -o APKINDEX.tar.gz *.apk && \
                abuild-sign -k /work/../../melange.rsa APKINDEX.tar.gz"

            ls -lh
            cd ../..
          else
            echo "No packages in cache, will attempt SourceForge download"
          fi

      - name: Install lftp for SourceForge downloads
        if: hashFiles('package-cache/${{ matrix.arch }}/*.apk') == ''
        run: |
          sudo apt-get update
          sudo apt-get install -y lftp

      - name: Download packages from SourceForge (fallback if cache empty)
        if: hashFiles('package-cache/${{ matrix.arch }}/*.apk') == ''
        run: |
          # SourceForge acts as fallback repository when cache is empty
          echo "=== Cache empty, downloading from SourceForge via lftp ==="

          # Use lftp to mirror from SourceForge public HTTP
          # Only download .apk files, exclude APKINDEX (we'll generate our own)
          lftp -c "
            set ssl:verify-certificate no
            set net:timeout 30
            set net:max-retries 3
            set net:reconnect-interval-base 5
            open https://sourceforge.net/projects/wolfi/files/
            mirror --verbose --parallel=3 \
              --include-glob '*.apk' \
              --exclude-glob '*' \
              ${{ matrix.arch }}/ ./package-cache/${{ matrix.arch }}/
          " || {
            echo "lftp mirror failed, repository may be empty or not accessible"
            echo "Downloaded 0 packages from SourceForge"
          }

          # Count downloaded packages
          PKG_COUNT=$(find ./package-cache/${{ matrix.arch }} -name "*.apk" 2>/dev/null | wc -l)
          echo "Downloaded $PKG_COUNT packages from SourceForge"

          # If we have packages, generate APKINDEX
          if [ "$PKG_COUNT" -gt 0 ]; then
            echo "Generating APKINDEX for SourceForge packages..."
            cd ./package-cache/${{ matrix.arch }}
            docker run --rm \
              -v $PWD:/work \
              -w /work \
              alpine:latest \
              sh -c "apk add --no-cache apk-tools abuild && \
                apk index --allow-untrusted -o APKINDEX.tar.gz *.apk && \
                abuild-sign -k /work/../../melange.rsa APKINDEX.tar.gz"
            ls -lh
            cd ../..
          else
            echo "No packages available from SourceForge, starting fresh build"
          fi

      - name: Build package with Melange
        run: |
          # Use direct path to package YAML file (flat structure like wolfi-os)
          PACKAGE_YAML="packages/${{ matrix.package }}.yaml"

          if [ ! -f "$PACKAGE_YAML" ]; then
            echo "Error: No YAML file found at $PACKAGE_YAML"
            exit 1
          fi

          echo "Building package: ${{ matrix.package }}"
          echo "Using configuration: $PACKAGE_YAML"
          echo "Target architecture: ${{ matrix.arch }}"

          # Build using Melange container
          # Use package-cache as local repository (contains cached + SourceForge packages)
          docker run --rm --privileged \
            -v $PWD:/work \
            -w /work \
            cgr.dev/chainguard/melange:latest \
            build \
            --arch ${{ matrix.arch }} \
            --signing-key melange.rsa \
            --keyring-append melange.rsa.pub \
            --keyring-append wolfi-signing.rsa.pub \
            --repository-append https://packages.wolfi.dev/os \
            --repository-append ./package-cache \
            --pipeline-dir pipelines \
            --generate-index \
            --out-dir ./build-output \
            "$PACKAGE_YAML"

      - name: List built packages
        run: |
          echo "=== Built APK packages for ${{ matrix.arch }} ==="
          ls -lh ./build-output/${{ matrix.arch }}/

          # Show package info
          for apk in ./build-output/${{ matrix.arch }}/*.apk; do
            if [ -f "$apk" ]; then
              echo "Package: $(basename $apk)"
              echo "Size: $(du -h $apk | cut -f1)"
            fi
          done

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: apk-packages-${{ matrix.package }}-${{ matrix.arch }}
          path: ./build-output/${{ matrix.arch }}/*.apk
          retention-days: 30
          if-no-files-found: error

      - name: Upload Melange signing key (for repository signing)
        if: matrix.package == 'stremio' && matrix.arch == 'x86_64'
        uses: actions/upload-artifact@v4
        with:
          name: melange-signing-key
          path: melange.rsa*
          retention-days: 1

  build-summary:
    name: Build Summary
    needs: build-packages
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: all-artifacts

      - name: Display build summary
        run: |
          echo "=== Build Summary ==="
          echo ""
          echo "Total artifacts:"
          find all-artifacts -name "*.apk" | wc -l
          echo ""
          echo "Total size:"
          du -sh all-artifacts
          echo ""
          echo "x86_64 packages:"
          find all-artifacts -path "*x86_64*" -name "*.apk" -exec basename {} \; | sort

  consolidate-cache:
    name: Consolidate Package Cache
    needs: [prepare-build-matrix, build-packages]
    runs-on: ubuntu-latest
    if: always()
    strategy:
      matrix:
        arch: ${{ fromJson(needs.prepare-build-matrix.outputs.architectures) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download all build artifacts for ${{ matrix.arch }}
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          pattern: 'apk-packages-*-${{ matrix.arch }}'

      - name: Restore existing package cache
        uses: actions/cache/restore@v4
        id: cache-restore
        with:
          path: ./consolidated-cache/${{ matrix.arch }}
          key: wolfi-packages-consolidated-${{ matrix.arch }}-${{ github.run_id }}
          restore-keys: |
            wolfi-packages-consolidated-${{ matrix.arch }}-

      - name: Consolidate packages into cache directory
        run: |
          echo "=== Consolidating packages into cache ==="
          mkdir -p ./consolidated-cache/${{ matrix.arch }}

          # Count existing cached packages
          EXISTING_COUNT=$(find ./consolidated-cache/${{ matrix.arch }} -name "*.apk" 2>/dev/null | wc -l || echo "0")
          echo "Existing packages in cache: $EXISTING_COUNT"

          # Copy all newly built packages
          echo "Copying newly built packages..."
          find artifacts -name "*.apk" -exec cp -v {} ./consolidated-cache/${{ matrix.arch }}/ \;

          # Count total packages
          TOTAL_COUNT=$(find ./consolidated-cache/${{ matrix.arch }} -name "*.apk" 2>/dev/null | wc -l)
          NEW_COUNT=$((TOTAL_COUNT - EXISTING_COUNT))

          echo ""
          echo "=== Cache Statistics ==="
          echo "Previously cached: $EXISTING_COUNT packages"
          echo "Newly added: $NEW_COUNT packages"
          echo "Total in cache: $TOTAL_COUNT packages"
          echo ""
          echo "Cache contents:"
          ls -lh ./consolidated-cache/${{ matrix.arch }}/*.apk 2>/dev/null | tail -20

      - name: Generate APKINDEX for cache
        run: |
          echo "=== Generating APKINDEX for cache ==="

          if ls ./consolidated-cache/${{ matrix.arch }}/*.apk 1> /dev/null 2>&1; then
            cd ./consolidated-cache/${{ matrix.arch }}

            # Generate APKINDEX using Alpine container
            docker run --rm \
              -v $PWD:/work \
              -w /work \
              alpine:latest \
              sh -c "apk add --no-cache apk-tools abuild && \
                apk index --allow-untrusted -o APKINDEX.tar.gz *.apk && \
                ls -lh APKINDEX.tar.gz"

            cd ../..
            echo "APKINDEX generated successfully"
          else
            echo "No packages to index"
          fi

      - name: Save consolidated cache
        uses: actions/cache/save@v4
        if: always()
        with:
          path: ./consolidated-cache/${{ matrix.arch }}
          key: wolfi-packages-consolidated-${{ matrix.arch }}-${{ github.run_id }}
